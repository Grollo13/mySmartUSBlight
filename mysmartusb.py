#/usr/bin/python3
import serial
import argparse
import os
import time


if __name__ == "__main__":


    commands = dict(
        AVR910Mode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x61]),
        BoardPowerOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x2d]),
        BoardPowerOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x2b]),
        QuiteMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x71]),
        RescueClockOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x63]),
        RescueClockOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x43]),
        ResqueClockOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x63]),
        ResqueClockOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x43]),
        STK500Mode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x73]),
        emulationStatus=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x74]),
        myMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x6d]),
        passthroughRS232=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x64]),
        power3V=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x33]),
        power5V=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x35]),
        powerOnBurnOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x77]),
        powerOnBurnOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x57]),
        powerOnBurnStatus=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x25]),
        powerStatus=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x5e]),
        programmingMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x6d]),
        resetBoard=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x72]),
        resetProgrammer=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x52]),
        saveMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x45]),
        setBaud19200=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x42, 0x33]),
        statusProgMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x49]),
        statusProgrammer=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x69]),
        version=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x76])
    )



    parser = argparse.ArgumentParser(
        description="mySmartUSB light Programmer Linux Utility"
    )

    parser.add_argument("device")
    parser.add_argument("command")

    config = parser.parse_args()

    if config.command not in commands:
        print("invalid command: " + config.command)
    else:
        ser = serial.Serial(config.device, 115200)
        ser.write(commands[config.command])
        ser.flush()
        time.sleep(0.1)
        response = bytes(ser.read(ser.inWaiting()))

        # Expected response structure (with <info> and <code> being 1 byte):
        # [0xF7 <info>] 0xF7 0xB1 <code> 0x0D 0x0A
        if len(response) is 5:
            if int.from_bytes(response, byteorder='big') & 0xF7B1000D0A == 0xF7B1000D0A:
                code = response[2]
                print("Response code: " + hex(code))
            else:
                print("Unexpected 5 byte response")
        elif len(response) is 7:
            if int.from_bytes(response, byteorder='big') & 0xF700F7B1000D0A is 0xF700F7B1000D0A:
                info = response[1]
                code = response[4]
                print("Response info: " + hex(info))
                print("Response code: " + hex(code))
            else:
                print("Unexpected 7 byte response")
        else:
            print("Unexpected response length (" + str(len(response)) + " bytes received)")

        ser.close()
