#/usr/bin/python3
import serial
import argparse
import os
import time

commands = dict(
        AVR910Mode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x61]),
        BoardPowerOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x2d]),
        BoardPowerOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x2b]),
        QuiteMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x71]),
        RescueClockOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x63]),
        RescueClockOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x43]),
        ResqueClockOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x63]),
        ResqueClockOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x43]),
        STK500Mode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x73]),
        emulationStatus=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x74]),
        myMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x6d]),
        passthroughRS232=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x64]),
        power3V=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x33]),
        power5V=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x35]),
        powerOnBurnOff=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x77]),
        powerOnBurnOn=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x57]),
        powerOnBurnStatus=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x25]),
        powerStatus=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x5e]),
        programmingMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x6d]),
        resetBoard=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x72]),
        resetProgrammer=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x52]),
        saveMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x45]),
        setBaud19200=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x42, 0x33]),
        statusProgMode=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x49]),
        statusProgrammer=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x69]),
        version=bytearray([0xe6, 0xb5, 0xba, 0xb9, 0xb2, 0xb3, 0xa9, 0x76])
    )

def evaluate_code(code, command):
    if command == "powerStatus":
        print("Power status: " + str(code & 0xF) + "V")
    if command == "emulationStatus":
        if code == 0x73:
            print("Emulation mode: STK500")
        if code == 0x61:
            print("Emulation mode: AVR911")
    if command == "powerOnBurnStatus":
        if code == 0x77:
            print("powerOnBurn is ON")
        if code == 0x57:
            print("powerOnBurn is OFF")
def evaluate_info(info, command):    
    if command == "version":
        print("Version: " + info.decode())

if __name__ == "__main__":
 
    parser = argparse.ArgumentParser(
        description="mySmartUSB light Programmer Linux Utility"
    )

    parser.add_argument("device")
    parser.add_argument("command")

    config = parser.parse_args()

    if config.command not in commands:
        print("invalid command: " + config.command)
    else:
        ser = serial.Serial(config.device, 115200)
        ser.write(commands[config.command])
        ser.flush()
        time.sleep(0.1)
        response = bytes(ser.read(ser.inWaiting()))

        # Expected response structure (with <info> being one or more bytes and <code> being one byte):
        # [0xF7 <info>] 0xF7 0xB1 <code> 0x0D 0x0A
        if len(response) is 5:
            if int.from_bytes(response, byteorder='big') & 0xF7B1000D0A == 0xF7B1000D0A:
                code = response[2]
                print("Response code: " + hex(code))
                evaluate_code(code, config.command)
            else:
                print("Unexpected 5 byte response")
        elif len(response) >= 7:
            if response[0] == 0xF7 and \
               int.from_bytes(response[-5:], byteorder='big') & 0xF7B1000D0A == 0xF7B1000D0A:
                info = response[1:-5]
                code = response[-2]
                print("Info (raw): " + hex(int.from_bytes(info, byteorder='big')))
                print("Code (raw): " + hex(code))
                evaluate_code(code, config.command)
                evaluate_info(info, config.command)
            else:
                print("Unexpected long response")
        else:
            print("Unexpected response")

        ser.close()
